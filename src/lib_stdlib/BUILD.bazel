load("@obazl_rules_ocaml//ocaml:rules.bzl",
     "ocaml_module",
     "ocaml_ns_archive",
     "ocaml_ns_library",
     "ocaml_signature",
     "ppx_executable")

ocaml_signature(
    name = "bits__sig",
    src = "bits.mli",
)

ocaml_module(
    name = "bits",
    sig = ":bits__sig",
    struct = "bits.ml",
)

ocaml_signature(
    name = "bloomer__sig",
    src = "bloomer.mli",
)

ocaml_module(
    name = "bloomer",
    ppx = ":ppx",
    # ppx_print = "@ppx//print:text",
    ppx_tags = ["inline-test"],
    sig = ":bloomer__sig",
    struct = "bloomer.ml",
    deps = [
        ## FIXME: ppx_codeps should obviate this
        # "@ppx_inline_test//:ppx_inline_test",
    ],
)

ocaml_signature(
    name = "bounded_heap__sig",
    src = "bounded_heap.mli",
)

ocaml_module(
    name = "bounded_heap",
    sig = ":bounded_heap__sig",
    struct = "bounded_heap.ml",
)

ocaml_signature(
    name = "circular_buffer__sig",
    src = "circular_buffer.mli",
    deps = [
        "@lwt//:lwt",
    ],
)

ocaml_module(
    name = "circular_buffer",
    sig = ":circular_buffer__sig",
    struct = "circular_buffer.ml",
)

ocaml_signature(
    name = "compare__sig",
    src = "compare.mli",
    deps = [
        "@zarith//:zarith",
    ],
)

ocaml_module(
    name = "compare",
    sig = ":compare__sig",
    struct = "compare.ml",
)

ocaml_signature(
    name = "fallbackArray__sig",
    src = "fallbackArray.mli",
)

ocaml_module(
    name = "fallbackArray",
    sig = ":fallbackArray__sig",
    struct = "fallbackArray.ml",
)

ocaml_signature(
    name = "lwt_dropbox__sig",
    src = "lwt_dropbox.mli",
    deps = [
        "@lwt//:lwt",
    ],
)

ocaml_module(
    name = "lwt_dropbox",
    sig = ":lwt_dropbox__sig",
    struct = "lwt_dropbox.ml",
)

ocaml_signature(
    name = "lwt_idle_waiter__sig",
    src = "lwt_idle_waiter.mli",
    deps = [
        "@lwt//:lwt",
    ],
)

ocaml_module(
    name = "lwt_idle_waiter",
    sig = ":lwt_idle_waiter__sig",
    struct = "lwt_idle_waiter.ml",
)

ocaml_signature(
    name = "lwt_pipe__sig",
    src = "lwt_pipe.mli",
    deps = [
        "@lwt//:lwt",
    ],
)

ocaml_module(
    name = "lwt_pipe",
    sig = ":lwt_pipe__sig",
    struct = "lwt_pipe.ml",
)

ocaml_signature(
    name = "lwt_utils__sig",
    src = "lwt_utils.mli",
    deps = [
        "@lwt//:lwt",
    ],
)

ocaml_module(
    name = "lwt_utils",
    sig = ":lwt_utils__sig",
    struct = "lwt_utils.ml",
)

ocaml_signature(
    name = "memory__sig",
    src = "memory.mli",
)

ocaml_module(
    name = "memory",
    sig = ":memory__sig",
    struct = "memory.ml",
)

ocaml_signature(
    name = "tag__sig",
    src = "tag.mli",
)

ocaml_module(
    name = "tag",
    sig = ":tag__sig",
    struct = "tag.ml",
)

ocaml_signature(
    name = "tzEndian__sig",
    src = "tzEndian.mli",
)

ocaml_module(
    name = "tzEndian",
    sig = ":tzEndian__sig",
    struct = "tzEndian.ml",
)

ocaml_signature(
    name = "tzFilename__sig",
    src = "tzFilename.mli",
)

ocaml_module(
    name = "tzFilename",
    sig = ":tzFilename__sig",
    struct = "tzFilename.ml",
)

ocaml_signature(
    name = "tzList__sig",
    src = "tzList.mli",
    deps = [
        ":bounded_heap",
    ],
)

ocaml_module(
    name = "tzList",
    sig = ":tzList__sig",
    struct = "tzList.ml",
    deps = [
        ":bounded_heap",
    ],
)

ocaml_signature(
    name = "tzString__sig",
    src = "tzString.mli",
)

ocaml_module(
    name = "tzString",
    sig = ":tzString__sig",
    struct = "tzString.ml",
    deps = [
        "@hex//:hex",
    ],
)

ocaml_signature(
    name = "utils__sig",
    src = "utils.mli",
)

ocaml_module(
    name = "utils",
    sig = ":utils__sig",
    struct = "utils.ml",
)

# okapi:auto
# okapi:public_name tezos-stdlib
# ocaml_ns_archive(
ocaml_ns_library(
    name = "Tezos_stdlib",
    submodules = [
        ":bits",
        ":bloomer",
        ":bounded_heap",
        ":circular_buffer",
        ":compare",
        ":fallbackArray",
        ":lwt_dropbox",
        ":lwt_idle_waiter",
        ":lwt_pipe",
        ":lwt_utils",
        ":memory",
        ":tag",
        ":tzEndian",
        ":tzFilename",
        ":tzList",
        ":tzString",
        ":utils",
    ],
    visibility = ["//visibility:public"],
)

################
ppx_executable(
    name = "ppx",
    main = "@ppx//driver",
    deps = [
        "@ppxlib//:ppxlib",
        "@ppx_inline_test//:ppx_inline_test"
    ],
    # ppx_codeps = ["@ppx_inline_test//:ppx_inline_test"]
)
